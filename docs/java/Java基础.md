### 目录
+ 1.程序设计
+ 2.面向对象
+ 3.Java语言
+ 4.对象
+ 5.类型
+ 6.泛型
+ 7.继承
+ 多态
+ 类型体系
+ 序列化

#### 1.程序设计
+ 程序设计其实是对复杂性的管理：待解决问题的复杂性，以及用来解决该问题的工具的复杂性；^[出自《Java编程思想-第四版》前言；]
+ Java的设计目标之一是：为程序员减少复杂性，减少开发健壮代码所需的时间以及困难；^[出自《Java编程思想-第四版》前言；]
  + 缩短了代码的开发时间（和C++相比）；
  + 着手解决日渐变得重要的各种复杂任务，比如多线程和网络编程；
  + 解决了一些相当大的复杂性问题：跨平台编程，动态代码修改以及安全的议题；
+ 如同任何人类语言一样，Java提供了一种表达概念的方式；如果使用得当，随着问题变得更庞大更复杂，这种表达工具将会比别的可供选择的语言更为简单，灵活；^[出自《Java编程思想-第四版》绪论；]
+

#### 2.面向对象
+ 所有的编程语言都提供抽象机制，能够解决的问题的复杂性直接取决于抽象的类型和质量；OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题；
+ 面向对象语言的五个特性：
  + 1.一切皆为对象；
  + 2.程序是对象的集合，通过发送消息来告知彼此所要做的；
  + 3.每个对象都有自己的以及其他对象所构成的存储；
  + 4.每个对象都拥有其类型；
  + 5.某一特定类型的所有对象都可以接收同样的消息；
+ 对象
  + 对象具有状态（内部数据），行为（方法调用）和标识（内存地址，以区分其他对象）；
  + 所有的对象都是唯一的，但是具有相同特性和行为的对象属于同一类型；
  + 对象都保证具有其类型信息（Java中）；
  + C++认为效率控制是最重要的议题，对象的存储空间和声明周期可以在编写程序时确定，将对象置于堆栈（自动变量或限域变量）或静态存储区来实现，由于声明周期在编写期已确定，自动或手动销毁对象；Java在堆中动态分配对象，通过垃圾回收器来进行对象销毁；
  +
+ 类型
  + 创建抽象数据类型是面向对象程序设计的几本概念之一；
  + 因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型；
  + 每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型；
  + 访问控制
    + 在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情；
    + 访问控制存在原因：一是让使用者无法触及他们不应该触及的部分；二是允许类创建者可以改变内部的工作方式而不用担心会影响使用者；
+ 抽象/封装
+ 复用
  + 代码复用是面向对象程序设计语言所提供的最了不起的优点之一；
+ 继承
  + 通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛；
  + 当继承现有类型时，也就创建了新的类型；新类型不仅包含现有类型的所有成员（尽管private成员被隐藏了起来，并且不可访问），而且更重要的是它复制了基类的接口；
  + 如果继承只覆盖基类的方法，意味着子类和基类是完全相同的类型（因为它们具有完全相同的接口），这种关系称之为“is-a”关系；如果要在子类中添加新的方法，这种关系称为“like-a”关系；
  + 在Java中，只支持单根继承；
    + 单根继承结构保证所有对象都具备某些功能；
    + 所有对象都可以容易的在堆上创建，而参数传递也得到了极大的简化；
    + 单根继承结构使得垃圾回收器的实现变得容易；
  + 继承存在的问题
    + equals的传递性：无法在扩展可实例化的类的同时，既增加新的值组件（新增域），同时又保留equals约定（非abstract有子类时，父类对象和子类对象equals时，违反对称性和传递性）；
+ 多态
  + 非面向对象编程的编译器产生的函数调用会引起所谓的前期绑定；然后在OOP中，程序直到运行时才能够确定代码的地址，即后期/动态绑定，编译器只是确保被调用的方法存在，并对调用参数和返回值进行类型检查；
  + 在Java中，动态绑定是默认行为；

#### 3.Java语言
+ Java程序设计语言是一门支持单继承的面向对象程序设计语言，在每个方法的内部，它也支持命令式（面向语句）的编码风格；^[出自《Effective Java第三版》推荐序]
+ 泛型
  + JAVA5中添加了参数化类型，即泛型；
  + Java SE8是Java语言在其历史上最大的演化版本；一组数量相对较小的特征，包括lambda表达式，方法引用和函数型接口，组合起来提供了融合面向对象风格和函数型风格的编程模型，这种融合是以鼓励最佳实践的方式完成的，包括不可变性，无状态性，组合性，同时，保留了“Java的感觉”，即可读性，简单性和普适性；^[出自《Java语言规范 基于Java SE8》前言]
  + Java编程语言是一种通用的，支持并发的，基于类的面向对象编程语言；Java编程语言是一种强静态类型语言，编译时通常是指将程序翻译称独立于机器的字节码形式的过程，运行时的活动包括对所需的类的加载和链接，非强制性的机器码生成和程序动态优化，以及实际的程序执行；^[出自《Java语言规范 基于Java SE8》第一章概述]
  + Java编程语言是一种静态类型语言，这意味着每个每个变量和每个表达式都具有在编译时就明确的类型；Java编程语言还是一种强类型语言，因为类型限制了变量可以持有的值和表达式可以产生的值，限定了在这些值上可以进行的操作，并确定了这些操作的含义；强静态类型机制有助于在编译时探测错误

#### 4.对象
+ **对象主要涉及以下四个方面：**
  1.概念
  2.Object
  3.何时以及如何创建对象
  4.何时以及如何避免创建对象
  5.对象的使用；
  6.适时地销毁对象以及在销毁之前进行清理动作；
<br>
+ **1.概念**
  + 对象存储在堆中，引用及基本类型可以存储在堆栈中（局部变量）；
  + 数组也是对象，当创建一个数组对象时，如果元素类型是引用类型，则每个元素都是null，如果元素类型是基本类型，则每个元素的值为0对应的基本类型值；数组队形都与一个Class对象关联，并且相同的元素类型共享该Class对象；
  + Java中，作用域（花括号）决定了在其内定义的变量名的可见行和生命周期；对象可存活于作用域之外；Java对象通过GC（垃圾回收器）自动销毁对象；
<br>
+ **2.Object**
  + 概念
    + Object类是类层次结构的根；是所有类（包括数组类）的超类；
    +
  + API
    | | API |备注|
    |--|---|---|
    |getClass|public final native Class<?> getClass()|返回运行时Class对象（擦除泛型信息）|
    |hashCode|public native int hashCode()||
    |equals|public boolean equals(Object obj)|
    |clone|protected native Object clone() throws CloneNotSupportedException|
    |toString|public String toString()|
    |notify|public final native void notify()|
    |notifyAll|public final native void notifyAll()|
    |wait|public final native void wait(long timeout) throws InterruptedException|
    |wait|public final void wait(long timeout, int nanos) throws InterruptedException|
    |wait|public final void wait() throws InterruptedException|
    |finalize|protected void finalize() throws Throwable|
    + getClass
      + 返回运行时Class对象（擦除泛型信息）；
    + hashCode & equals
      + hashCode约定
        + 假如equals中用到的信息没有被修改，在程序运行中，hashCode返回的值应该是一致的；如果是下一次运行，则该值无需保持一致；
        + 如果两个对象equals返回true，则hashCode也必须返回一样的值；
        + 如果两个对象equals返回false，则无需hashCode返回不一样的值；但是如果不同的对象，返回不同的hashCode，散列表中可以提升性能；
      + equals约定
        + 自反性：任何非null的x，`x.equals(x)`必须返回true；
        + 对称性：任何非null的x和y，`x.equals(y) == y.equals(x)`；
        + 传递性：任何非null的x，y和z，`x.equals(y)`返回true，并且`y.equals(z)`返回true时，`x.equals(z)`也必须返回true；
        + 一致性：任何非null的x和y，只要equals中的比较操作没有被修改，多次调用`x.equals(y)`返回的值保持一致；
        + 非空性：任何非null的x，`x.equals(null)`必须返回false；
        +
      + equals被覆盖时，总要覆盖hashCode；
      + 不要将equals声明中的Object对象替换为其他的类型；因为这是重载，而不是重写；
      + 理想情况下，散列函数应该把集合中不想等的实例均匀的分布到所有可能的int值上；
    + clone
      + clone约定
        + 对于非null的x，`x.clone() != x`返回true，`x.clone().getClass() == x.getClass`返回true，`x.clone().equals(x)`返回true；但是都不是绝对的要求；
        + 返回的对象应该通过调用`super.clone`获得；
        + 返回的对象应该不依赖于被克隆的对象，为了实现这种独立性，在返回`super.clone()`对象之前，需要修改对象相关域；如果类中包含基本类型的域或者不可变对象的引用，则无需修改；如果类中包含可变对象的引用，要么递归调用可变对象的clone方法（提供了行为良好的clone方法），要么重新创建对象；
      + 实现Cloneable接口的类是为了提供一个功能适当的clone方法；由此得到一种语言之外的机制：无需调用构造器就可以创建对象；
      + 不可变的类永远不应该提供clone方法；
      + 数组是clone方法唯一被吸引人的用法；
      + Cloneable架构与引用可变对象final域的正常用法是不想兼容的，除非在原始对象和克隆对象之间可以安全的共享此可变对象；
      + 所有实现了Cloneable接口的类都应该覆盖clone方法，并且是公有的方法，它的返回类型为类本身；该方法应该先调用`super.clone`方法，然后修正任何需要修正的域；
      + 拷贝构造器以及静态工厂方法，都比Cloneable/clone方法具有更多的优势，它们不依赖于某一种很有风险的，语言之外的对象创建机制；它们不要求遵守尚未制定好文档的规范；它们不会与final域的正常使用发生冲突；它们不会抛出不必要的受检异常；它们不需要进行类型转换；
      + 复制功能最好由构造器或者工厂提供；例外是数组，最好利用clone方法复制数组；
    + toString
      + 应该返回简洁，有意义的信息；
    + wait & notify/notifyAll
      + wait
        + 将当前线程放到某个对象的等待集中，并放弃该对象的监视器，直到另外一个线程调用notify/notifyAll，调用该线程的中断方法或者带时间的wait方法时间耗尽之后，被线程调用选中，从该对象的等待集中删除，并同其他线程竞争该锁，一旦该线程获取了锁，等同于wait方法返回；
        + 除了notify/notifyAll/interrupted/wait时间耗尽，还有其他方式会唤醒（实践中，极少情况），在这种情况下，wait应该始终处于迭代循环中，即使唤醒了线程，也要重新测试条件；
        + 调用wait时，该线程必须拥有该对象的监视器，即必须在同步方法或者同步代码中调用；
      + notify/notifyAll
        + 唤醒一个或者所有在该对象的等待集的线程；
        + 调用notify/notifyAll时，该线程必须拥有该对象的监视器，即必须在同步方法或者同步代码中调用；
    + finalize
<br>

+ **3.如何创建对象**
  + 构造方法(new)；
  + 静态工厂
    + 优点一：有名字（一个类只能由一个带有指定签名的构造器）；
    + 优点二：不必在每次调用时都创建新对象；
      + 可控制类实例；
      + 避免创建对象带来的性能消耗；
      + 不可变的值类（String）不存在相等的实例，这是享元模式的基础，枚举类型保证了这一点；
    + 优点三：可以返回返回类型的任何子类型的对象；
      + 提供了更大的灵活性；
      + 适用于基于接口的框架：返回对象，同时又不会使对象的类变成公有的；
    + 优点四：返回对象的类可以基于参数动态变化；
    + 优点五：返回的对象所属的类，可以在编译阶段不存在；
      + 静态工厂方法构成了服务提供者框架（Service Provider Framework）的基础；
    + 缺点一：类如果没有公有的或者受保护的构造器，就不能子类化；
    + 缺点二：使用者很难发现；API文档中，没有像构造方法那样明确标识出来；
  + Builder
    + 构造方法和静态工厂都有个共同的局限性：不能很好的扩展到大量的可选参数；
    + JavaBeans模式可以适应大量可选参数的场景，但是存在着很严重的缺点：
      + 在构造过程中，JavaBean可能处于不一致的状态，类无法仅仅通过检查参数有效性来保证一致性；
      + 构造过程中，无法保证有效对象的原子性；
      + JavaBeans模式不可能使类成为不可变的；
    + Builder模式
      + 不直接生成对象，先生成对应的builder对象，在builder对象上设置参数，然后调用`build()`生成对象；
      + Builder模式模拟了具名的可续啊参数；
      + Builder模式也适应于类层次结构；
        + Builder类型是泛型，带有一个递归类型参数（recursive type parameter）；
        + 子类方法声明返回基类的返回类型的子类型，这被称作协变返回类型；
      + Builder模式比较灵活，可以单个Builder构建多个对象，在构建对象期间对参数进行调整；
    + Singleton
      + Singleton是指只能够被实例化一次的类；
      + 实现Singleton的方法
        + 1.公有静态final域
          + 构造器私有化；
          + 防止反射生成多个对象，可以在构造方法中创建第二个对象时抛出异常；
          + 如果需要支持序列化，所有实例域都是瞬时的（transient）的，并提供一个readResolve方法；
        + 2.公有静态方法
          + 构造器私有化；
          + 防止反射生成多个对象，可以在构造方法中创建第二个对象时抛出异常；
          + 如果需要支持序列化，所有实例域都是瞬时的（transient）的，并提供一个readResolve方法；
        + 3.单元素枚举类
          + 和共有final域类似，但更加简洁，无偿提供了序列化机制，防止多次实例化（即使面对复杂的序列化或者反射攻击的时候）；
          + 单元素的枚举类经常成为实现Singleton的最佳方法；
          + 如果Singleton必须继承一个超类，则不宜适应该方法；
      + clone
      + 反序列化
+ **4.何时以及如何避免创建对象**
  + 只包含静态域和静态方法的类，不希望被实例化；
    + 缺少显式构造方法的情况下，编译器会自动提供一个公有的，无参的缺省构造方法；
    + 提供私有的构造方法，并在构造方法中`throw`异常，避免反射或者内部生成对象；
    + 有个副作用：不能被子类化；
  + 复用对象
    + 最好能复用单个对象，而不是每次需要的时候创建一个相同的新对象；如果对象是不可变的（immutable），它就始终是可重用的；
    + String.matchs方法虽然最易于查看一个字符串是否与正则表达式相匹配，但并不适合在注重性能的场景中重复使用；因为内部会创建一个Pattern实例，却只用一次，就可以GC回收了；创建Pattern实例的成本很高，因为需要将正则表达式编译成一个有限状态机；
    + 尽量使用String字面常量，因为字面常量指向的是同一个对象；
  + 避免无意识的自动装箱
    + 尽量使用基本类型而不是对应的装箱类型，当心无意识的自动装箱；
  + 对象池
    + 通过维护自己的对象池（object pool）来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的；
+ **5.对象的使用**
+ **6.适时地销毁对象以及在销毁之前进行清理动作**
  + 消除过期的对象引用
    + 对于集合中采用数组作为数据结构的，size之外的引用需及时清除；
    + 支持垃圾回收的语言中，内存泄漏是很隐蔽的；内存泄漏的场景分类
      + 只要类是自己管理内存，就应该警惕内存泄漏问题；
      + 缓存；
      + 监听器和其他回调；
  + 避免使用终结方法`finalize()`
    + 终结方法通常是不可预测的，也是很危险的；
    + Java语言规范并不保证哪个线程会执行终结方法；
    + 如果忽略在终结过程中发生抛出来的未被捕获的异常，终结过程也会终止；并且对象处于破坏状态，如果其他线程企图使用被破坏的对象，则可能发生不确定的行为；
    + 有非常严重的性能损失；
    + 严重的安全问题
      + 如果从构造器或它的序列化对等体（`readObject`和`readResolve`方法）抛出异常，恶意子类的终结方法就可以在构造了一部分的破坏对象上运行（终结方法中将该对象指向静态变量）；
      + final类不会受到终结方法攻击；
      + 防止非final类受到终结方法攻击，要编写一个空的final的`finalize()`方法；
    + 终结方法的使用场景
      + 资源的所有者忘记调用close方法时，终结方法或清除方法可以充当“安全网”；
      + 如果存在一个本地对等体没有关键资源，并且性能可以接收的化，在终结方法或清除方法中进行本地对等体的内存回收；
  + 清除方法
    + 清除方法是Java9中引入的；
    + 清除方法没有终结方法那么危险，但仍然是不可预测，运行缓慢的；
    + 类的设计者可以控制自己的清除线程，但清除方法仍然在后台运行，处于垃圾回收器的控制之下，因此不能确保及时清除；
    + 有严重的性能损失；
  + 关闭资源
    + `try finally`
      + 手动在finally中关闭资源，无论正常结束还是抛出异常，都会关闭资源；
      + 如果在try块和finally块中都抛出了异常，finally块的异常会覆盖try块的异常；
    + `try-with-resources`
      + Java7引入；
      + 资源必须实现`AutoCloseable`接口，其中包含了单个返回void的close方法；
      + 如果try块和close都抛出异常，则保留第一个异常，后续的异常会被禁止，并打印在堆栈轨迹中；编程中可以通过`getSuppressed`方法访问被禁止的异常；
#### 5.类型
+ Java中的类型可以分为两类：简单类型和引用类型；
  + 简单类型
    + boolean
    + byte
    + short
    + int
    + long
    + char
    + float
    + double
  + 引用类型
    + 类类型/接口类型
      + 类或接口类型由一个标志符或由圆点分隔的标识符序列构成，其中每个标识符后面都可选的包含类型引元；如果类型引元出现在类或接口的任何地方，那么该类就是一个参数化类型；
      + 在类或接口类型中的每个标识符都会被当作包名或类型名，其中被当作类型名额标识符可以被注解；
      + 泛化类或泛化接口的声明定义了一个参数化类型集；
      + 参数化类型是形式为C<T<sub>1</sub>, ..., T<sub>n</sub>> 的类或接口，其中C是泛型名，<T<sub>1</sub>, ..., T<sub>n</sub>> 是表示该泛型的特定参数化形式的类型引元列表；
      + 泛化类或泛化接口带有类型参数F<sub>1</sub>, ..., F<sub>n</sub> ，并且这些类型参数还带有相应的边界 B<sub>1</sub>, ..., B<sub>n</sub>；参数化类型的每个类型引元T<sub>i</sub>都是限定在对应的边界中列出的所有类型的任何子类型的范围内；
      + 如果满足下列条件，那么参数化类型C<T<sub>1</sub>, ..., T<sub>n</sub>> 就是良构的：
        + C是泛型名；
        + 类型引元的数量与在C的泛化声明中的类型参数的数量相同；
        + 当经过捕获转换并产生类型C<X<sub>1</sub>, ..., T<sub>n</sub>> 后，对于在每一个在B<sub>i</sub>中的边界类型S，每一个类型引元X<sub>i</sub>都是S[F<sub>1</sub>:=X<sub>1</sub>, ..., F<sub>n</sub>:=X<sub>n</sub>] 的子类型；
      + 如果满足下列两个条件之一，就被认为可证不同的：
        + 它们是不同的泛型定义的参数化版本；
        + 它们的任何类型引元都是可证不同的；
      + 参数化类型可以是对嵌套的泛化类或泛化接口的参数化版本；
      + 类型引元可以是引用类型或通配符；
      + 通配符
        + `? extends B` 指定通配符的上界；
        + `? super B` 指定通配符的下界；
        + `? extends Object` 等价于无界通配符；
      + 如果两个类型引元满足下列条件之一，就被认为是可证不同的：
        + 引元既不是类型变量，也不是通配符，并且两个引元不是相同的类型；
        + 其中一个类型引元是类型变量或通配符，且具有上界（来自捕获转换，如果这种转换是必须的）S；而另一个类型引元不是类型变量或通配符，并且|S|<:|T|和|T|<:|S|都不成立；
        + 两个类型引元都是类型变量或通配符，且具有上界（来自捕获异常，如果这种转换是必须额）S和T，并且|T|<:|S|和|T|<:|S|都不成立；
      + 如果C是具有类型参数 A<sub>1</sub>, ..., A<sub>n</sub> 的泛化类或泛化接口声明，而C<T<sub>1</sub>, ..., T<sub>n</sub>>是对C的参数化版本，其中T<sub>i</sub>是类型（而不是通配符），那么：
        + 如果m是C中的成员或构造器声明，其声明类型是T，那么m在 C<T<sub>1</sub>, ..., T<sub>n</sub>> 中的类型就是T[A<sub>1</sub>:=T<sub>1</sub>, ..., A<sub>n</sub>:=T<sub>n</sub>]；
        + 如果m是D中的成员或构造器声明，其中D是C扩展的类或实现的接口，并且如果 D<U<sub>1</sub>, ..., U<sub>k</sub>> 是 C<T<sub>1</sub>, ..., T<sub>n</sub>> 对应于D的超类型，那么m在 C<T<sub>1</sub>, ..., T<sub>n</sub>> 中的类型就是m在 D<U<sub>1</sub>, ..., U<sub>k</sub>> 中的类型；
      + 如果C的参数化版本中任意一个或多个类型引元是通配符，那么：
        + 在 C<T<sub>1</sub>, ..., T<sub>n</sub>> 中的域，方法和构造器的类型就是在 C<T<sub>1</sub>, ..., T<sub>n</sub>> 的捕获转换中的域，方法和构造器的类型；
        + 如果D是C中的类或接口声明（可能是泛化的），那么D在 C<T<sub>1</sub>, ..., T<sub>n</sub>> 中的类型就是D，如果D是泛化的，那么所有类型引元都是无界通配符；
      + 在泛型声明中声明的static成员必须使用对应于该泛型的非泛型来引用；
    + 类型变量
      + 类型变量是在类，接口，方法和构造器中用作类型的非限定标识符；类型变量可以声明为泛化类声明，泛化接口声明，泛化方法声明和泛化构造器声明中的类型参数；
      + 边界
        + 每个声明为类型参数的类型变量都有一个边界；
        + 如果对某个类型变量没有声明任何边界，则默认其边界为Object；
        + 如果声明了边界，则有两种情况：
          + 单个类型变量T；
          + 类或接口类型T，后面有可选接口类型 I<sub>1</sub>&...&I<sub>n</sub>；
        + 对于边界来说，其所有构成类型的擦除必须都是互不相同的，否则就会产生编译时错误；
        + 类型在边界中的顺序只有在两种情况下才显得重要：
          + 第一种是类型变量的擦除取决于边界的第一个类型；
          + 第二种是类类型或类型变量只能出现在第一个类型的位置；
        + 边界为 T&I<sub>1</sub>&...&I<sub>n</sub> 的类型变量的x的成员，是由位于类型变量声明处的交集类型 T&I<sub>1</sub>&...&I<sub>n</sub> 的成员构成的；
    + 数组类型
    + 空类型
      + 因为没有名字，所以无法声明一个空类型的变量，也不能将变量类型转换为空类型；
      + 空类型只能是空类型表达式的值；
      + 空引用总是可以被赋值给或被类型转换为任何引用类型；
+ 对象是动态创建的类类型的实例或者是动态创建的数组；
+ 对应于简单类型和引用类型，有两种数据值：简单值和引用值；
  + 值可以被存储在变量中，当作引元传递，作为返回值，或者在其上执行操作；
  + 简单值之间不共享状态；
  + 简单值都有各自的取值范围；
  + 简单类型都有大量的操作符；
  + 引用值是指向对象的指针，并且有一个特殊的空引用，它不指向任何对象；
+ 引用类型相同
  + 如果两个引用类型具有相同的二进制名字，并且如果它们有类型引元的话，通过递归地运用本定义，也可以认为它们是相同的，那么这两个引用类型就是相同的编译时类型；称其为同一个类或同一个接口；
  + 如果都是类或接口类型，由相同的类加载器定义，并且具有相同的二进制名字，则被称为同一个运行时类或同一个运行时接口；
  + 如果都是数组类型，并且其成员类型也都是同一个运行时类型，则是同一个运行时类型；
+ 类型擦除
  + 类型擦除是一种映射，将类型（可能包含参数化类型和类型变量）映射为（不再是参数化类型或类型变量的）类型，用|T|表示类型T的擦除；
  + 参数化类型 G<T<sub>1</sub>, ..., T<sub>n</sub>> 的擦除是 |G|；
  + 嵌套类型T.C的擦除是|T|.C；
  + 数组类型T[]的擦除是|T|[]；
  + 类型变量的擦除是其最左边界的擦除；
  + 每种其他类型的擦除都是该类型自身；
  + 构造器/方法的擦除
    + 类型擦除也会将构造器或方法的签名映射为没有任何参数化类型或类型变量的签名；构造器或方法的签名的擦除还是一个签名：由相同的名字以及所有给定的形参类型的擦除构成；
    + 如果构造器或方法的签名被擦除，那么返回类型或类型参数也都要被擦除；
+ 原生类型
  + 为了促进与非泛化遗留代码之间的交互，可以将参数化类型的擦除或元素类型为参数化类型的数组类型的擦除当作类型使用；这种类型被称为原生类型；
  + 以下类型都被定义为原生类型：
    + 引用类型，且其蚕蛹某种泛化声明的名字，但是没有任何类型引元列表；
    + 数组类型，且其元素类型为原生类型；
    + 具有原生类型R的非静态成员类型，且其并非从R的超类型或超接口继承而来；
  + 非泛化的类或接口类型不是原生类型；
  + 原生类型的超类或超接口是泛型的任意参数化版本的超类或超接口的擦除；
  + 构造器的类型，实例方法的类型，以及并非从超类或超接口继承而来的具有原生类型C的非静态的类型，都是原生类型，这些原生类型对应于有关C的泛化声明中其类型的擦除；
  + 具有原生类型C的静态方法或静态域的类型与有关C的泛化声明中的类型相同；
  + 一个类的超类型可以是原生类型，对这个类的成员访问会当作普通的成员分访问进行处理，而对其超类型的成员访问会当作原生类型的访问进行处理；
  + 使用原生类型，是为了兼容遗留代码而不得已采用的一种折中方式；在泛型被引入到Java中之后，就不再鼓励在代码中使用原生类型；
+ 交集类型
  + 交集类型的形式为 T<sub>1</sub>&...&T<sub>n</sub> ，其中T<sub>i</sub>是类型表达式；
  + 交集类型可以从类型参数边界和类型转换表达式派生，它们可以在捕获转换和最低上边界计算的过程中产生；
  + 每一个交集类型 T<sub>1</sub>&...&T<sub>n</sub> 都可以归纳为一个概念类或接口，用来标识交集类型的成员；
  + 交集类型和类型变量的边界之间的差异值得深思；每个类型变量的边界都会归纳为一个交集类型；边界的形式是受限的，只有第一个元素可以是类或类型变量，并且在边界中只能出现一个类型变量；但是，捕获转换可能会导致创建出更加普遍（例如数组类型）的类型变量；
+ 可具化类型
  + 因为有些类型信息在编译时会被擦除，所以并非所有类型都是在运行时可用的；在运行时完全可用的类型被称为可具化类型；
  + 一个类型当切且仅当满足以下条件之一时，才是可具化类型：
    + 非泛化的类或接口；
    + 参数化类型，所有的类型引元都是无界的通配符；
    + 原生类型；
    + 简单类型；
    + 数组类型，且其元素类型是可具化的；
    + 潜逃类型，且其中`.`分隔开的每一个类型T都是可具化的；
  + 交集类型不是可具化的；
+ 子类型化
  + 子类型和超类型之间的关系是类型上的二元关系；S:>T表示S和T之间的超类型关系；如果S:>T，且S!=T，则S是T的真超类型，用S>T表示；如果S是T的直接超类，用S<sub>1</sub>>T表示；
  + 子类型化并为扩展至参数化类型，T<:S不表示 `C<T> <: C<S>`；
  + 简单类型之间的子类型化
    + double ><sub>1</sub> float
    + float ><sub>1</sub> long
    + long ><sub>1</sub> int
    + int ><sub>1</sub> char
    + int > <sub>1</sub> short
    + short ><sub>1</sub> byte
  + 非泛型声明C，则类型C的直接超类型为如下所有类型：
    + C的直接超类；
    + C的直接超接口；
    + Object，如果C是没有任何直接超接口的接口类型；
  + 泛型声明 C<F<sub>1</sub>, ..., F<sub>n</sub>> ，原生类型C的直接超类型为如下所有类型：
    + 原生类型C的直接超类；
    + 原生类型C的直接超接口；
    + Object类型，如果 C<F<sub>1</sub>, ..., F<sub>n</sub>> 是没有任何直接超接口的泛化接口类型；
  + 泛型声明 C<F<sub>1</sub>, ..., F<sub>n</sub>> ，泛型 C<F<sub>1</sub>, ..., F<sub>n</sub>> 的直接超类型为如下所有类型：
    + C<F<sub>1</sub>, ..., F<sub>n</sub>> 的直接超类型；
    + C<F<sub>1</sub>, ..., F<sub>n</sub>> 的直接超接口；
    + Object类型，如果 C<F<sub>1</sub>, ..., F<sub>n</sub>> 是没有任何直接超接口的泛化接口类型；
    + 原生类型C；
  + 泛型声明 C<F<sub>1</sub>, ..., F<sub>n</sub>> ，参数化类型 C<F<sub>1</sub>, ..., F<sub>n</sub>> 的直接超类型为如下所有类型：
    + ？？？
  + 泛型声明 C<F<sub>1</sub>, ..., F<sub>n</sub>> ，如果参数化类型 C<R<sub>1</sub>, ..., R<sub>n</sub>> 中至少一个R<sub>i</sub>是通配符类型引元，那么其直接超类型就是参数化类型 C<X<sub>1</sub>, ..., X<sub>n</sub>> 的直接超类型，而 C<X<sub>1</sub>, ..., X<sub>n</sub>> 是将捕获转换应用于 C<R<sub>1</sub>, ..., R<sub>n</sub>> 后产生的结果；
  + 交集类型 T<sub>1</sub>, ..., T<sub>n</sub> 的直接超类型是T<sub>i</sub>
  + 类型变量的直接超类型是在其边界中所列出的类型；
  + 类型变量是其下边界的直接超类型；
  + 空类型的直接超类型是除空类型自身之外的所有引用类型；
  + 数组类型之间的子类型化
    + 如果S和T都是引用类型，当且仅当S><sub>1</sub>T时，S[]><sub>1</sub>T[]；
    + Object><sub>1</sub>Object[]；
    + Cloneable><sub>1</sub>Object[]；
    + java.io.Serializable><sub>1</sub>Object[]；
    + 如果P是简单类型：
      + Object><sub>1</sub>P[]；
      + Cloneable><sub>1</sub>P[]；
      + java.io.Serializable><sub>1</sub>P[]；
+ 类型，类和接口
  + 在Java中，每个变量和表达式都有一个在编译时可以确定的类型；
  + 在Java虚拟机中，每个对象都属于某个特定的类；每个数组也都有一个类；
  + 变量的编译时类型总是声明的类型，而表达式的编译时类型是可以在编译时推断的；编译时类型会对变量在运行时可以持有的值或表达式在运行时产生的值进行限定；
  + 编译时类型和运行时类型不完全一致由以下两个原因造成的：
    + 不同的加载器加载的完全相同的类或接口定义，但是产生的运行时类不是相同的；
    + 类型变量和类型引元在运行时是没有具化的；
