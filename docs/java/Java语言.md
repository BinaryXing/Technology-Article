### 目录
+ 1.文法
+ 2.符号
+ 3.名字
+ 4.变量
+ 5.表达式

#### 1.文法
+ 上下文无关文法由大量的产生式构成，每个产生式的左部都是一个被称为“非终结符”的抽象符号，右部是一个符号序列，由一个或多个非终结符和终结符构成；对于每一种文法，终结符都来自指定的字母表；
+ 词法
  + 词法以Unicode字符集中的字符作为终结符，并且定义了一组产生式，描述了从目标符号Input开始，Unicode字符序列如何被转译成输入元素序列；这些输入元素序列在将空白字符和注释剔除之后，就形成了Java句法中的终结符，即符号（token），包括标志符，关键字，字面常量，分隔符和操作符；
  + 程序是用Unicode编写的，但是Java提供了词法翻译，使得程序可以仅使用ASCII字符，通过Unicode转译字符来使用任何Unicode字符；
  + 词法翻译
    + 1.将原始的Unicode字符流中的Unicode转译字符翻译成相应的Unicode字符；
    + 2.将上一步生成的Unicode流翻译成由输入字符和行终止符构成的流；
      + 行终止符定义的行可以用来确定Java编译器产生的行号；
    + 3.将上一步生成的输入字符和行终止符构成的流翻译成由输入元素序列；
      + 不是空白字符和注释的输入元素被称为符号，是句法的终结符；
      + 符号包括标志符，关键字，字面常量，分隔符，操作符；
+ 句法
  + 句法以词法定义的符号（token）作为其终结符，并定义了一组产生式，描述了从目标符号CompilationUnit开始，单词序列可以如何构成句法上正确的程序；

#### 2.符号
+ 标志符
  + 标识符是没有长度限制的由Java字母和数字构成的序列，其中首字符必须是Java字母；
  + “Java字母”是Character.isJavaIdentifierStart(int)返回true的字符；“Java字母或数字”是Character.isJavaIdentifierPart(int)返回true的字符；“Java字母”包括大小写的ASCII拉丁字母A-Z和a-z以及下划线`_`和美元符号`$`；“Java数字”包含ASCII数字0-9；
  + 标识符的拼写不能与关键字，布尔字面常量，空字面常量或编译时发生的错误的拼写相同；
<br>
+ 关键字
  + Java中保留了50个关键字，都是由ASCII字母构成的字符序列，不能当作标识符来使用；
    + abstract
    + assert
    + boolean
    + break
    + byte
    + case
    + catch
    + char
    + class
    + const
    + continue
    + default
    + do
    + double
    + else
    + enum
    + extends
    + final
    + finally
    + float
    + for
    + if
    + goto
    + implements
    + import
    + instanceof
    + int
    + interface
    + long
    + native
    + new
    + package
    + private
    + protected
    + public
    + return
    + short
    + static
    + strictfp
    + super
    + switch
    + synchronized
    + this
    + throw
    + throws
    + transient
    + try
    + void
    + volatile
    + while
  + 尽管不用const和goto，但仍旧保留了；
  + 尽管true和false看起来应当被当作关键字，但是从技术上来讲，它们仅仅是布尔字面常量；与此类似，null也仅仅只是空字面常量；
<br>
+ 字面常量
  + 字面常量是类型为简单类型，String类型和空类型的值在源程序中的表示；
  + 如果字面常量超出所属类型（比如int，long，float等）的范围，则产生编译时错误；
  + 整数字面常量
    + 整数字面常量后缀`l`或`L`表示long类型，否则为int类型；
    + 整数字面常量可以表示成十进制，十六进制（前缀`0x`或`0X`），八进制（前缀`0`）或二进制（前缀`0b`或者`0B`）；
    + 下划线`_`可以作为各个数字位之间的分隔符；
  + 浮点数字面常量
    + 浮点数字面常量包含几个部分：整数部分，小数点，小数部分，指数以及后缀类型；
    + 浮点数字面常量后缀`f`或`F`表示float类型，否则为double类型；
    + 浮点字面常量可以表示成十进制或十六进制；
    + 下划线`_`可以作为分隔符使用；
    + 可以使用Float或者Double类中定义的常量`POSITIVE_INFINITY`和`NEGATIVE_INFINITY`表示无穷值；
  + 布尔字面常量
    + 布尔字面常量由两个值：`true`和`false`；
  + 字符字面常量
    + 字符字面常量是由ASCII单引号括起来的单个字符或单个转义字符；
    + 字符字面常量的类型总是char类型；
  + 字符串字面常量
    + 字符串字面常量是由双引号括起来的0个或多个字符构成的；
    + 字符串字面常量总是String类型；
    + 字符串字面常量是对String类的实例的引用；一个字符串字面常量总是引用String类的同一个实例，因为字符串字面常量或者常量表达式的值的字符串，被通过使用`String.intern`方法而限定了；
      + 通过常量表达式运算得到的字符串是编译时计算出来的，并且之后将其当作字面常量；
      + 在运行时通过连接运算得到的字符串是新创建的对象；

  + 空类型字面常量
    + `null`
<br>
+ 分隔符
  + 分隔符总共有12个：`(`，`)`，`{`，`}`，`[`，`]`，`;`，`,`，`.`，`...`，`@`，`::`
<br>
+ 操作符
  + 操作符总共有38个
    + `=`
      + 赋值操作符，右值可以是任何常数，变量或表达式（只要能生成一个值就行），左值必须是一个明确的，已命名的变量；
    + `==`
    + `+`
    + `+=`
    + `>`
    + `>=`
    + `-`
    + `-=`
    + `<`
    + `<=`
    + `*`
    + `*=`
    + `!`
    + `!=`
    + `/`
    + `/=`
    + `~`
    + `&&`
    + `&`
    + `&=`
    + `?`
    + `||`
    + `|`
    + `|=`
    + `:`
    + `++`
    + `^`
    + `^=`
    + `->`
    + `--`
    + `%`
    + `%=`
    + `<<`
    + `<<=`
    + `>>`
    + `>>=`
    + `>>>`
    + `>>>=`
  + 操作符接受一个或多个参数，并生成一个新值；
  + 几乎所有的操作符都只能操作“基本类型”；`=`，`==`，`!=`可以操作多有的对象；String类支持`+`，`+=`；
  + 优先级
    + 操作符的优先级决定了各部分的计算顺序；
<br>
#### 3.名字
+ 名字被用来引用在程序中声明的实体；被声明的实体有：
  + 包
  + 导入类型
    + 包括单类型导入声明和按需类型导入声明；
  + 导入的static成员
    + 包括但静态导入声明和静态按需导入声明；
  + 类
  + 接口
  + 类型变量
    + 声明为泛化类，泛化接口，泛化方法和泛化构造器的类型参数；
  + 引用类型的成员
    + 成员类
    + 成员接口
    + 枚举常量
    + 域
      + 类类型或枚举类型中声明的域；
      + 接口类型或注解类型中声明的域；
      + length域；
    + 方法
      + 类类型或枚举类型中声明的方法（abstract或具体的）；
      + 接口类型或注解类型中声明的方法（abstract）；
    + 参数
      + 类类型或枚举类型中的方法或构造器的形参，或lambda表达式的形参；
      + 接口类型或注解类型的抽象方法的形参；
      + try语句的catch子句中声明的异常处理器的异常参数；
    + 局部变量
      + 在语句块中声明的局部变量；
      + 在for语句中声明的局部变量；
+ 程序中的名字要么是简单名（单一标识符构成的名字），要么是限定名（由`.`分隔开的标识符序列构成的名字）；
+ 每个引入名字的声明都有一个作用域；
+ 
#### 4.变量
+ 一个变量就是一个存储位置，并且具有相关联的类型（编译时类型）；
+ 变量的值可以通过赋值或前缀或后缀的`++`和`--`操作符来进行修改；
+ 变量分为两种：
  + 简单类型的变量
    + 值是简单值，其类型与该简单类型精确匹配；
  + 引用类型的变量
    + 类类型T的变量可以持有空引用，或者是T类以及T的任意子类的实例的引用；
    + 接口类型T的变量可以持有空引用，或者是实现了该接口的任意类的实例的引用；
    + 如果T是简单类型，“T的数组”类型的变量可以持有空引用，或者“T的数组”类型的数组的引用；
    + 如果T是引用类型，“T的数组”类型的变量可以持有空引用，或者”S的数组”类型的数组的引用，其中S类型是T类型的子类或子接口；
    + Object类型的变量，可以持有空引用，或者任意对象（包括类实例和数组）的引用；
    + Object[]类型的变量可以持有任意引用类型数组的引用；
    + 堆污染
      + 参数化类型的变量可能会引用不是该参数化类型的对象，这种情况称为堆污染；
      + 只有在程序执行某些产生编译时非受检警告的涉及原生类型的操作时，或者当程序通过超类型是原生类型或非泛化类型的数组变量对不可具化的数组变量起别名时，才会发生堆污染；
      + 变量并不能保证总是对其声明类型的子类型的引用，而只能保证是对其声明类型的子类或子接口的引用；
      + 如果没有任何操作会触发编译时非受检警告，并且具有不可具化的元素类型的数组变量不会产生任何不安全的别名操作，那么堆污染就不会发生；
    + 变量的种类
      + 类变量
        + 类变量是在类或接口的准备阶段创建的，并且被初始化为缺省值；
        + 类变量在类或接口被卸载时被有效的终止生命周期；
      + 实例变量
      + 数组成员
        + 是不具名变量，在数组对象被创建时就被创建并初始化为缺省值；
        + 数组成员在数组不再被引用时，被有效的终止声明周期；
      + 方法参数
        + 对传递给方法的引元值进行命名；
        + 在方法每次被调用时，方法参数都会被创建新的参数变量，被初始化为方法调用中相应的引元值；当方法执行完成后，方法参数被有效的终止生命周期；
      + 构造器参数
        + 对传递给构造器的引元值进行命名；
        + 在类实例创建表达式或显式的构造器调用中对构造器的每次调用都会创建新的参数变量，初始化为相应的引元值，当构造器体执行完成后，构造器参数被有效的终止生命周期；
      + lambda参数
        + 对传递给lambda表达式体的引元值进行命名；
      + 异常参数
        + 每当异常被try语句的catch子句捕获时，就会创建一个异常参数；新变量会被初始化与异常相关联的实际对象，catch子句执行完成后，被有效的终止生命周期；
      + 局部变量
        + 由局部变量生命语句声明；
        + 局部变量声明可以包含初始化变量的表达式；
        + 只有在赋值后局部变量才能使用；
    + final变量
      + final变量只能被赋值一次；
      + 有三种变量被隐式声明为final：接口的域，带资源的try语句中的资源，以及多重catch子句中的异常参数；单catch子句中的异常参数永远都不会被隐式的声明为final，但是它可以被认为效果等同于final；
#### 5.表达式
+ 程序中的许多动作都是通过表达式完成的，计算表达式要么是为了它们的副作用，例如对变量赋值；要么是为了得到它们的值，将其用作更大的表达式的引元或操作数，或者用来影响语句的执行顺序；或者是同时为了这两个目的；
+
